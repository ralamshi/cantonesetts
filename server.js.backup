const express = require('express');
const cors = require('cors');
const path = require('path');
const { GoogleTTSClient } = require('./services/providers/googleTTS');
const { MicrosoftTTSClient } = require('./services/providers/microsoftTTS');
const { TranslateService } = require('./services/translateService');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;

// åˆå§‹åŒ–æ‰€æœ‰æœå‹™
const googleTTS = new GoogleTTSClient();
const microsoftTTS = new MicrosoftTTSClient();
const translateService = new TranslateService();

// ä¸­é–“ä»¶
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(express.static(path.join(__dirname, 'public')));

// è«‹æ±‚æ—¥èªŒä¸­é–“ä»¶
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path} - ${req.ip}`);
    next();
});

// å¥åº·æª¢æŸ¥
app.get('/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV || 'development',
        services: {
            googleTTS: googleTTS.client ? 'Ready' : 'Not configured',
            microsoftTTS: microsoftTTS.isConfigured ? 'Ready' : 'Not configured',
            translateService: translateService.isConfigured ? 'Ready' : 'Not configured'
        },
        uptime: process.uptime(),
        memory: process.memoryUsage()
    });
});

// Favicon è™•ç†
app.get('/favicon.ico', (req, res) => {
    res.status(204).end();
});

// èªéŸ³åˆæˆ API
app.post('/api/v1/synthesize', async (req, res) => {
    try {
        const {
            text,
            engine = 'google',
            voice = 'yue-HK-Standard-A',
            language = 'yue',
            rate = 1.0,
            pitch = 0.0,
            volume = 1.0
        } = req.body;

        // é©—è­‰è¼¸å…¥
        if (!text || text.trim().length === 0) {
            return res.status(400).json({
                success: false,
                message: 'è«‹è¼¸å…¥è¦æœ—è®€çš„æ–‡å­—',
                code: 'EMPTY_TEXT'
            });
        }

        if (text.length > 5000) {
            return res.status(400).json({
                success: false,
                message: 'æ–‡å­—é•·åº¦ä¸èƒ½è¶…é 5000 å­—ç¬¦',
                code: 'TEXT_TOO_LONG'
            });
        }

        // æ¸…ç†å’Œæº–å‚™æ–‡å­—
        const cleanText = text.trim();
        
        console.log(`ğŸ¤ TTS è«‹æ±‚: ${engine} | ${language} | ${voice} | "${cleanText.substring(0, 50)}${cleanText.length > 50 ? '...' : ''}"`);

        let audioContent;
        const startTime = Date.now();
        
        // æ ¹æ“šå¼•æ“é¸æ“‡ TTS æœå‹™
        if (engine === 'microsoft') {
            if (!microsoftTTS.isConfigured) {
                return res.status(503).json({
                    success: false,
                    message: 'Microsoft Azure TTS æœå‹™æœªé…ç½®',
                    code: 'AZURE_NOT_CONFIGURED'
                });
            }
            
            audioContent = await microsoftTTS.synthesize({
                text: cleanText,
                voice,
                language,
                rate: parseFloat(rate),
                pitch: parseFloat(pitch),
                volume: parseFloat(volume)
            });
        } else if (engine === 'openai') {
            // é ç•™ OpenAI TTS æ”¯æ´
            return res.status(501).json({
                success: false,
                message: 'OpenAI TTS åŠŸèƒ½é–‹ç™¼ä¸­',
                code: 'OPENAI_NOT_IMPLEMENTED'
            });
        } else {
            // é»˜èªä½¿ç”¨ Google TTS
            if (!googleTTS.client) {
                return res.status(503).json({
                    success: false,
                    message: 'Google Cloud TTS æœå‹™æœªé…ç½®',
                    code: 'GOOGLE_NOT_CONFIGURED'
                });
            }
            
            audioContent = await googleTTS.synthesize({
                text: cleanText,
                voice,
                language,
                rate: parseFloat(rate),
                pitch: parseFloat(pitch),
                volume: parseFloat(volume)
            });
        }

        const processingTime = Date.now() - startTime;

        res.json({
            success: true,
            audioContent,
            metadata: {
                engine,
                voice,
                language,
                textLength: cleanText.length,
                processingTime: `${processingTime}ms`,
                timestamp: new Date().toISOString(),
                audioFormat: 'mp3',
                audioSize: Math.round(audioContent.length * 0.75) // ä¼°ç®—å­—ç¯€å¤§å°
            }
        });

    } catch (error) {
        console.error('âŒ TTS API éŒ¯èª¤:', error);
        
        // è©³ç´°éŒ¯èª¤è™•ç†
        let errorMessage = error.message || 'èªéŸ³åˆæˆå¤±æ•—';
        let errorCode = 'TTS_ERROR';
        
        if (error.message.includes('INVALID_ARGUMENT')) {
            errorMessage = 'èªéŸ³åƒæ•¸ç„¡æ•ˆï¼Œè«‹æª¢æŸ¥èªéŸ³é¸æ“‡';
            errorCode = 'INVALID_VOICE';
        } else if (error.message.includes('UNAUTHENTICATED')) {
            errorMessage = 'API èªè­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥é…ç½®';
            errorCode = 'AUTH_ERROR';
        } else if (error.message.includes('QUOTA_EXCEEDED')) {
            errorMessage = 'API é…é¡å·²ç”¨å®Œï¼Œè«‹ç¨å¾Œå†è©¦';
            errorCode = 'QUOTA_EXCEEDED';
        }

        res.status(500).json({
            success: false,
            message: errorMessage,
            code: errorCode,
            debug: process.env.NODE_ENV === 'development' ? {
                stack: error.stack,
                details: error.message
            } : undefined
        });
    }
});

// ç¿»è­¯ API
app.post('/api/v1/translate', async (req, res) => {
    try {
        const { text, from, to } = req.body;

        // é©—è­‰è¼¸å…¥
        if (!text || text.trim().length === 0) {
            return res.status(400).json({
                success: false,
                message: 'è«‹è¼¸å…¥è¦ç¿»è­¯çš„æ–‡å­—',
                code: 'EMPTY_TEXT'
            });
        }

        if (text.length > 5000) {
            return res.status(400).json({
                success: false,
                message: 'æ–‡å­—é•·åº¦ä¸èƒ½è¶…é 5000 å­—ç¬¦',
                code: 'TEXT_TOO_LONG'
            });
        }

        if (!from || !to) {
            return res.status(400).json({
                success: false,
                message: 'è«‹æŒ‡å®šç¿»è­¯èªè¨€',
                code: 'MISSING_LANGUAGES'
            });
        }

        // å¦‚æœæºèªè¨€å’Œç›®æ¨™èªè¨€ç›¸åŒï¼Œç›´æ¥è¿”å›åŸæ–‡
        if (from === to) {
            return res.json({
                success: true,
                translatedText: text.trim(),
                originalText: text.trim(),
                from,
                to,
                isSameLanguage: true,
                timestamp: new Date().toISOString()
            });
        }

        const cleanText = text.trim();
        console.log(`ğŸŒ ç¿»è­¯è«‹æ±‚: ${from} -> ${to} | "${cleanText.substring(0, 50)}${cleanText.length > 50 ? '...' : ''}"`);

        const startTime = Date.now();
        const translatedText = await translateService.translateText(cleanText, from, to);
        const processingTime = Date.now() - startTime;

        res.json({
            success: true,
            translatedText,
            originalText: cleanText,
            from,
            to,
            processingTime: `${processingTime}ms`,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('âŒ ç¿»è­¯ API éŒ¯èª¤:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'ç¿»è­¯å¤±æ•—',
            code: 'TRANSLATE_ERROR',
            debug: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
});

// èªéŸ³åˆ—è¡¨ API
app.get('/api/v1/voices', async (req, res) => {
    const { engine = 'google', language = 'yue' } = req.query;
    
    try {
        let voices = [];
        
        if (engine === 'microsoft') {
            if (!microsoftTTS.isConfigured) {
                return res.status(503).json({
                    success: false,
                    message: 'Microsoft Azure TTS æœå‹™æœªé…ç½®',
                    code: 'AZURE_NOT_CONFIGURED'
                });
            }
            voices = await microsoftTTS.getVoices(language);
        } else if (engine === 'openai') {
            // é ç•™ OpenAI èªéŸ³åˆ—è¡¨
            voices = [];
        } else {
            // Google èªéŸ³ï¼ˆå¾å›ºå®šåˆ—è¡¨ï¼‰
            const googleVoices = {
                yue: [
                    { id: 'yue-HK-Standard-A', name: 'æ›‰ç¾', gender: 'female' },
                    { id: 'yue-HK-Standard-B', name: 'å®¶æ˜', gender: 'male' },
                    { id: 'yue-HK-Standard-C', name: 'å°æ™´', gender: 'female' },
                    { id: 'yue-HK-Standard-D', name: 'é˜¿ä»”', gender: 'male' }
                ],
                en: [
                    { id: 'en-US-Standard-C', name: 'Emma', gender: 'female' },
                    { id: 'en-US-Standard-A', name: 'James', gender: 'male' },
                    { id: 'en-US-Standard-E', name: 'Sophie', gender: 'female' },
                    { id: 'en-US-Standard-D', name: 'David', gender: 'male' }
                ],
                ja: [
                    { id: 'ja-JP-Standard-A', name: 'éº»è¡£', gender: 'female' },
                    { id: 'ja-JP-Standard-C', name: 'å¤ªéƒ', gender: 'male' }
                ],
                ko: [
                    { id: 'ko-KR-Standard-A', name: 'ì§€ì€', gender: 'female' },
                    { id: 'ko-KR-Standard-C', name: 'ë¯¼ìˆ˜', gender: 'male' }
                ],
                de: [
                    { id: 'de-DE-Standard-G', name: 'Anna', gender: 'female' },
                    { id: 'de-DE-Standard-H', name: 'Hans', gender: 'male' }
                ]
            };
            voices = googleVoices[language] || [];
        }
        
        res.json({
            success: true,
            voices,
            engine,
            language,
            count: voices.length,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ èªéŸ³åˆ—è¡¨ API éŒ¯èª¤:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'ç²å–èªéŸ³åˆ—è¡¨å¤±æ•—',
            code: 'VOICES_ERROR'
        });
    }
});

// æ¸¬è©¦ Google Cloud é…ç½®
app.post('/api/v1/test-google', (req, res) => {
    try {
        if (!process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
            return res.status(400).json({
                success: false,
                message: 'Google æœå‹™å¸³æˆ¶é‡‘é‘°æœªé…ç½®',
                code: 'MISSING_GOOGLE_KEY'
            });
        }

        const credentials = JSON.parse(process.env.GOOGLE_SERVICE_ACCOUNT_KEY);
        
        res.json({
            success: true,
            message: 'Google Cloud é…ç½®æ­£å¸¸',
            projectId: credentials.project_id,
            clientEmail: credentials.client_email,
            hasPrivateKey: !!credentials.private_key,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('âŒ Google é…ç½®æ¸¬è©¦éŒ¯èª¤:', error);
        res.status(500).json({
            success: false,
            message: 'Google Cloud é…ç½®éŒ¯èª¤',
            code: 'GOOGLE_CONFIG_ERROR',
            error: error.message
        });
    }
});

// æ¸¬è©¦ Azure é…ç½®
app.post('/api/v1/test-azure', async (req, res) => {
    try {
        if (!microsoftTTS.isConfigured) {
            return res.status(400).json({
                success: false,
                message: 'Azure èªéŸ³æœå‹™æœªé…ç½®',
                code: 'AZURE_NOT_CONFIGURED',
                details: {
                    hasKey: !!process.env.AZURE_SPEECH_KEY,
                    hasRegion: !!process.env.AZURE_SPEECH_REGION,
                    region: process.env.AZURE_SPEECH_REGION || 'not set'
                }
            });
        }

        // æ¸¬è©¦ç²å– token
        const startTime = Date.now();
        await microsoftTTS.getAccessToken();
        const processingTime = Date.now() - startTime;
        
        res.json({
            success: true,
            message: 'Microsoft Azure TTS é…ç½®æ­£å¸¸',
            region: microsoftTTS.region,
            tokenUrl: microsoftTTS.tokenUrl,
            ttsUrl: microsoftTTS.ttsUrl,
            processingTime: `${processingTime}ms`,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('âŒ Azure é…ç½®æ¸¬è©¦éŒ¯èª¤:', error);
        res.status(500).json({
            success: false,
            message: 'Azure TTS é…ç½®éŒ¯èª¤',
            code: 'AZURE_CONFIG_ERROR',
            error: error.message,
            details: {
                region: microsoftTTS.region,
                hasKey: !!process.env.AZURE_SPEECH_KEY
            }
        });
    }
});

// æ¸¬è©¦ç¿»è­¯æœå‹™é…ç½®
app.post('/api/v1/test-translate', async (req, res) => {
    try {
        if (!translateService.isConfigured) {
            return res.status(400).json({
                success: false,
                message: 'ç¿»è­¯æœå‹™æœªé…ç½®',
                code: 'TRANSLATE_NOT_CONFIGURED'
            });
        }

        // é€²è¡Œä¸€å€‹ç°¡å–®çš„ç¿»è­¯æ¸¬è©¦
        const testText = 'ä½ å¥½';
        const startTime = Date.now();
        const result = await translateService.translateText(testText, 'yue', 'zh');
        const processingTime = Date.now() - startTime;
        
        res.json({
            success: true,
            message: 'ç¿»è­¯æœå‹™é…ç½®æ­£å¸¸',
            testTranslation: {
                original: testText,
                translated: result,
                from: 'yue',
                to: 'zh'
            },
            processingTime: `${processingTime}ms`,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('âŒ ç¿»è­¯æœå‹™æ¸¬è©¦éŒ¯èª¤:', error);
        res.status(500).json({
            success: false,
            message: 'ç¿»è­¯æœå‹™é…ç½®éŒ¯èª¤',
            code: 'TRANSLATE_CONFIG_ERROR',
            error: error.message
        });
    }
});

// ç³»çµ±æŒ‡æ¨™ API
app.get('/api/v1/metrics', (req, res) => {
    res.json({
        success: true,
        metrics: {
            uptime: process.uptime(),
            memory: process.memoryUsage(),
            cpu: process.cpuUsage(),
            nodeVersion: process.version,
            platform: process.platform,
            arch: process.arch
        },
        services: {
            googleTTS: googleTTS.client ? 'Ready' : 'Not configured',
            microsoftTTS: microsoftTTS.isConfigured ? 'Ready' : 'Not configured',
            translateService: translateService.isConfigured ? 'Ready' : 'Not configured'
        },
        timestamp: new Date().toISOString()
    });
});

// åŸºæœ¬è·¯ç”±
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// 404 è™•ç†
app.use('*', (req, res) => {
    res.status(404).json({
        success: false,
        message: 'æ‰¾ä¸åˆ°è«‹æ±‚çš„è³‡æº',
        code: 'NOT_FOUND',
        path: req.originalUrl,
        method: req.method,
        timestamp: new Date().toISOString()
    });
});

// å…¨å±€éŒ¯èª¤è™•ç†
app.use((error, req, res, next) => {
    console.error('ğŸ’¥ æœªè™•ç†çš„éŒ¯èª¤:', error);
    
    res.status(500).json({
        success: false,
        message: 'ä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤',
        code: 'INTERNAL_SERVER_ERROR',
        timestamp: new Date().toISOString(),
        debug: process.env.NODE_ENV === 'development' ? {
            message: error.message,
            stack: error.stack
        } : undefined
    });
});

// å„ªé›…é—œé–‰è™•ç†
process.on('SIGTERM', () => {
    console.log('ğŸ”„ æ”¶åˆ° SIGTERM ä¿¡è™Ÿï¼Œæ­£åœ¨å„ªé›…é—œé–‰...');
    server.close(() => {
        console.log('âœ… ä¼ºæœå™¨å·²é—œé–‰');
        process.exit(0);
    });
});

process.on('SIGINT', () => {
    console.log('ğŸ”„ æ”¶åˆ° SIGINT ä¿¡è™Ÿï¼Œæ­£åœ¨å„ªé›…é—œé–‰...');
    server.close(() => {
        console.log('âœ… ä¼ºæœå™¨å·²é—œé–‰');
        process.exit(0);
    });
});

// æœªæ•ç²çš„ç•°å¸¸è™•ç†
process.on('uncaughtException', (error) => {
    console.error('ğŸ’€ æœªæ•ç²çš„ç•°å¸¸:', error);
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('ğŸ’€ æœªè™•ç†çš„ Promise æ‹’çµ•:', reason);
    console.error('ğŸ’€ Promise:', promise);
    process.exit(1);
});

// å•Ÿå‹•æœå‹™å™¨
const server = app.listen(PORT, () => {
    console.log('\nğŸ‰ === LoveNSay å¤šèªè¨€ TTS ç³»çµ±å·²å•Ÿå‹• ===');
    console.log(`ğŸš€ æœå‹™å™¨é‹è¡Œåœ¨: http://localhost:${PORT}`);
    console.log(`ğŸ“ ç’°å¢ƒ: ${process.env.NODE_ENV || 'development'}`);
    console.log(`ğŸ• å•Ÿå‹•æ™‚é–“: ${new Date().toLocaleString('zh-TW')}`);
    console.log('\nğŸ“‹ æœå‹™ç‹€æ…‹:');
    console.log(`   ğŸ”§ Google TTS: ${googleTTS.client ? 'âœ… æº–å‚™å°±ç·’' : 'âŒ æœªé…ç½®'}`);
    console.log(`   ğŸ”§ Microsoft TTS: ${microsoftTTS.isConfigured ? 'âœ… æº–å‚™å°±ç·’' : 'âŒ æœªé…ç½®'}`);
    console.log(`   ğŸ”§ ç¿»è­¯æœå‹™: ${translateService.isConfigured ? 'âœ… æº–å‚™å°±ç·’' : 'âŒ æœªé…ç½®'}`);
    console.log('\nğŸ”— å¯ç”¨ç«¯é»:');
    console.log(`   ğŸ“Š å¥åº·æª¢æŸ¥: http://localhost:${PORT}/health`);
    console.log(`   ğŸ¤ èªéŸ³åˆæˆ: POST http://localhost:${PORT}/api/v1/synthesize`);
    console.log(`   ğŸŒ ç¿»è­¯æœå‹™: POST http://localhost:${PORT}/api/v1/translate`);
    console.log(`   ğŸ“‹ èªéŸ³åˆ—è¡¨: GET http://localhost:${PORT}/api/v1/voices`);
    console.log(`   ğŸ“ˆ ç³»çµ±æŒ‡æ¨™: GET http://localhost:${PORT}/api/v1/metrics`);
    console.log('=====================================\n');
});

module.exports = app;